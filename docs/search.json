[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Postagens",
    "section": "",
    "text": "Migrando meu blog\n\n\n\n\n\nAgora utilizando o framework quarto para escrever e gerenciar o conteúdo\n\n\n\n\n\n07.09.2024\n\n\nGiliard Godoi\n\n\n\n\n\n\n\n\n\n\n\n\nApresentação no 14º Engitec\n\n\n\n\n\nFalando um pouco sobre desenvolvimento de modelos de IA com um exemplo prático sobre Entidades Nomeadas\n\n\n\n\n\n05.06.2024\n\n\nGiliard Godoi\n\n\n\n\n\n\n\n\n\n\n\n\nGuia rápido para a biblioteca configparser\n\n\n\n\n\nManipulação de arquivos de configuração do tipo config.ini e config.cfg\n\n\n\n\n\n26.05.2024\n\n\nGiliard Godoi\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/2024/configparser-guia-rapido/index.html",
    "href": "posts/2024/configparser-guia-rapido/index.html",
    "title": "Guia rápido para a biblioteca configparser",
    "section": "",
    "text": "Existem várias especificações para arquivos de configuração ou parametrização, tais como os arquivos ini, yaml, e toml. Cada uma dessas especificações define uma forma de organizar as informações e representar tipos comuns das linguagens de programação como inteiros (int), números de ponto flutuante (float), valores booleanos (bool), strings, e até mesmo estruturas de dados como listas e dicionários.\nNessa postagem vamos conhecer um pouco sobre a biblioteca padrão da linguagem Python para manipular arquivos ini, a biblioteca configparser.\nEssa especificação foi inicialmente projetadas para sistemas do Microsoft Windows, porém, com o tempo, passou a ser adotada por outras empresas, aparecendo inclusive em softwares open source sob a extensão cfg.\nVamos cobrir algumas funcionalidades básicas dessa biblioteca e, para um entendimento mais detalhado, o leito interessado poderá consultar a documentação oficial da bibliotecaconfigparser.\n\nDefinição do arquivo\nO arquivo de configuração ini é organizado por seções, representada por uma palavra entre colchetes. Todo arquivo possui uma seção default que vem no início do arquivo. Os parâmetros são definidos sob o esquema chave e valor em cada uma das seções.\nAs principais características desse formato são:\n\nPodem ser utilizados como delimitadores de valor os caracteres ‘=’ ou ‘:’.\nComentários são precedidos pelo caracter ‘#’\nTodos os valores são convertidos para string, e por padrão não existe a conversão dos valores para tipos básicos da linguagem.\nPorém, existem alguns métodos especiais para converter os valores para determinado tipo;\nAo realizar o parse de um arquivo, a estrutura de dados retornados se assemelha a um dicionário do Python.\n\nA seguir, é mostrado um exemplo de como um arquivo de configuração é definido\n\nconfiguration_string = '''\n[DEFAULT]\nname  = Giliard Godoi\nemail = ggodoi@email.com\nlocal = Brasil\nsecret_agent = True\nyear = 2020\n\n# Isso é um comentário\n\n[education]  # Define-se uma nova seção com colchetes\nschool = Federal University of Technology - Paraná\nmajor  = Software Development\nyear   = 2018\n\n# This is a list of skills\n[skills]\nprograming :\n    Python\n    JavaScript\n    C\n    C++\n\nlanguage :\n    Portuguese\n    English\n'''\n\nPara manipular esse arquivo, vamos fazer a importação da biblioteca.\n\nimport configparser\n\nDepois instanciamos um objeto do tipo ConfigParser, porém ele ainda está vazio, isto é, sem campos ou valores definidos.\n\nconfig = configparser.ConfigParser()\n\ntype(config)\n\nconfigparser.ConfigParser\n\n\nA partir do objeto config, podemos realizar o parse de uma string de configuração da seguinte maneira, populando as suas seções e valores.\n\n\nconfig.read_string(configuration_string)\n\ntype(config)\n\nconfigparser.ConfigParser\n\n\nCada seção é acessível pelo seu nome, de forma semelhante a um dicionário.\n\n# O que é uma seção?\nconfig['DEFAULT']\n\n&lt;Section: DEFAULT&gt;\n\n\nO método sections retorna quais as seções definidas pelo arquivo. No nosso exemplo temos as seções education e skills. Note que a seção DEFAULT não é retornada.\n\n# Como saber quais são as demais seções?\nconfig.sections()\n\n['education', 'skills']\n\n\nTambém é possível verificar se uma seção existe em um arquivo de configuração pelo método has_section ou pelo o operator in.\n\n# Como verificar se uma seção existe dentro de config?\n('education' in config) or config.has_section('education')\n\nTrue\n\n\nPara conhecer quais os parâmetros de uma seção, podemos utilizar o método options passando o nome de uma seção.\n\nconfig.options('education')\n\n['school', 'major', 'year', 'name', 'email', 'local', 'secret_agent']\n\n\nMas se utilizarmos esse método para tentar descobrir as opções da seção DEFAULT nós obtemos um erro\n\ntry:\n    config.options('DEFAULT')\nexcept Exception as e:\n    print(type(e), e)\n\n&lt;class 'configparser.NoSectionError'&gt; No section: 'DEFAULT'\n\n\nIsso porque a seção default serve como um default. Isto é, se procurarmos uma opção em uma das seções e essa opção não estiver definida para aquela seção, o valor retornado será aquele presente na seção DEFAULT. Veja o exemplo a seguir:\n\nprint(\n    config.get('education', 'year'),\n)\nprint(\n    config.get('skills', 'year') # não foi definido a opção year nesta seção\n)\n\n2018\n2020\n\n\nPorém, o método defaults retorna um dicionário contendo os parâmetros e respectivos valores presentes nessa seção.\n\nconfig.defaults()\n\n{'name': 'Giliard Godoi',\n 'email': 'ggodoi@email.com',\n 'local': 'Brasil',\n 'secret_agent': 'True',\n 'year': '2020'}\n\n\nÉ possível verificar ser uma opção foi definida em uma seção através do método has_option.\n\n# Como verificar se existe uma opção (chave) dentro de uma seção?\nconfig.has_option(section='education', option='year')\n\nTrue\n\n\nNesse método, se o valor correspondente a section for passado como None ou uma string vazia, o valor da opção definida na seção DEFAULT é retornado.\n\n# Como verificar se existe uma opção para a seção default?\nconfig.has_option(section=None, option='company')\n\nFalse\n\n\nOs valores das opções (ou parâmetros) também estão acessíveis por indexação.\n\n# Como acessar um valor na seção default?\nconfig['DEFAULT']['name']\n\n'Giliard Godoi'\n\n\n\n# Como acessar um valor em uma outra seção?\nconfig['education']['school']\n\n'Federal University of Technology - Paraná'\n\n\nTambém é definio o método get para acessar o valor definido nos parâmetros. Como parâmetros esses métodos recebem o nome da seção e da opção que queremos consultar.\n\n# ou então, utilizar o método get\nconfig.get(section='education', option='school')\n\n'Federal University of Technology - Paraná'\n\n\nÉ importante dizer que a operação de parser do arquivo de configuração .ini não realiza a conversão dos dados para tipos primitivos da linguagem. Assim, todos os valores são retornados como string.\n\n# Qual é o tipo de dado retornado por padrão?\ntype(\n    config['education']['year']\n)\n\nstr\n\n\nA lista de linguagens de programação por exemplo, são retornadas como uma string e cada valor é separado pelo caracter de quebra de linha \\n.\n\n# Isso serve também para listas?\nconfig['skills']['programing']\n\n'\\nPython\\nJavaScript\\nC\\nC++'\n\n\nPara retornar esses valores como uma lista de strings, podemos utilizar o método split, conforme o exemplo a seguir.\n\n# Como converter os valores para listas?\nconfig['skills']['programing'].split()\n\n['Python', 'JavaScript', 'C', 'C++']\n\n\nExistem alguns métodos derivados de get que realizam a conversão para tipos primitivos, sendo eles: - getint - getboolean - getfloat\n\n# Como converter o valor de uma variável para um tipo específico?\nprint(f'''\n-----------------------------------\n{config.get(section='education', option='school')} : {type(config.get(section='education', option='school'))}\n{config.getint('education', 'year')} : {type(config.getint('education', 'year'))}\n{config.getboolean('DEFAULT', 'secret_agent')} : {type(config.getboolean('DEFAULT', 'secret_agent'))}\n-----------------------------------\n''')\n\n\n-----------------------------------\nFederal University of Technology - Paraná : &lt;class 'str'&gt;\n2018 : &lt;class 'int'&gt;\nTrue : &lt;class 'bool'&gt;\n-----------------------------------\n\n\n\n\ntype(\n    config.getint('education', 'year')\n)\n\nint\n\n\n\ntype(\n    config.getboolean('DEFAULT', 'secret_agent')\n)\n\nbool\n\n\nO método get também define um parâmetro fallback que é retornado se a opção desejada não existe na seção e nem foi definida em default.\n\n# É possível definir um valor fallback nos métodos get?\nassert not config.has_option(section='company', option='name')\n\nconfig.get(section='company', option='name', fallback='Does not exist')\n\n'Does not exist'\n\n\nTambém é possível retornar um dicionário com os parâmetros e respectivos valores presentes em uma seção. Note que todos os valores discriminados na seção default também são retornados. Isso pode ser bom ou uma falha de segurança, a depender do caso.\n\n# Como obter os itens (chave-valor) para uma seção?\nconfig.items('education')\n\n[('name', 'Giliard Godoi'),\n ('email', 'ggodoi@email.com'),\n ('local', 'Brasil'),\n ('secret_agent', 'True'),\n ('year', '2018'),\n ('school', 'Federal University of Technology - Paraná'),\n ('major', 'Software Development')]\n\n\n\n# Como obter os itens (chave-valor) para a seção default?\nconfig.defaults()\n\n{'name': 'Giliard Godoi',\n 'email': 'ggodoi@email.com',\n 'local': 'Brasil',\n 'secret_agent': 'True',\n 'year': '2020'}\n\n\n\n\nArquivos\nO arquivo de configuração definido no início dessa postagem pode ser salvo passando um ponteiro de arquivo para o método write.\n\n# Como salvar as configurações em um arquivo?\nwith open('config.ini', 'w') as f:\n    config.write(f)\n\nPara ler novamente esse arquivo, podemos fazer a leitura desse arquivo através do método read.\n\n# Como ler o arquivo config.ini?\nother = configparser.ConfigParser()\nother.sections() # o arquivo está vazio\n\n[]\n\n\n\nother.read('config.ini')\n\n['config.ini']\n\n\n\nother.sections()\n\n['education', 'skills']\n\n\n\n\nReferências\n\nhttps://docs.python.org/3/library/configparser.html\nhttps://en.wikipedia.org/wiki/INI_file\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts.\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/2024/migrating-blog-to-quarto/index.html",
    "href": "posts/2024/migrating-blog-to-quarto/index.html",
    "title": "Migrando meu blog",
    "section": "",
    "text": "Por que eu decidi outro gerenciador de conteúdo?\nPor algum tempo eu usei o framework Pelican para escrever os posts e gerar as páginas em html desse site. E a experiência foi boa!\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/2024/engitec-apresentacao/index.html",
    "href": "posts/2024/engitec-apresentacao/index.html",
    "title": "Apresentação no 14º Engitec",
    "section": "",
    "text": "No dia 05 de junho de 2024 eu fiz uma apresentação remota no 14º Encontro do Grupo Interlegis de Tecnologia, o EnGITEC.\nO tema do encontro desse ano foi Legislativo Inteligente, e eu fiz uma apresentação sobre Inteligência Artifical, dando uma ideia sobre como é o desenvolvimento de um modelo de Aprendizado de Máquina (Machine Learning).\nO objetivo principal aqui foi apresentar um exemplo prático de como é feito o desenvolvimento de um modelo supervisionado de IA. Para tanto, eu abordei um problema de Reconhecimento de Entidades Nomeadas em proposições legislativas.\nEssa tarefa consiste em identificar de forma automática entidades como nomes de pessoas, organizações, valores monetários, em um documento.\nAbaixo, eu disponibilizo os slides da apresentação e o código do projeto apresentado.\n\nSlides da apresentação\nRepostitório com o código do projeto apresentado\n\n\n\n\n Back to top"
  }
]